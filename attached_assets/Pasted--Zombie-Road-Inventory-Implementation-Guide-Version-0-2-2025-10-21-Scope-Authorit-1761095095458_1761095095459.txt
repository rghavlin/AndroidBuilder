# Zombie Road – Inventory Implementation Guide

**Version:** 0.2 (2025‑10‑21)
**Scope:** Authoritative reference for implementing and wiring the Inventory system into the game UI with small, reversible changes.
**Audience:** Contributors and tool/agent workers (e.g., Replit Assistant).

---

## 1) Core principles (read first)

* **Small, reversible diffs.** Each change should be isolated to a single phase and a tiny set of files.
* **No scope creep.** If a change is not explicitly listed in the active phase, do not make it.
* **Global grid size is fixed.** Chosen **once at startup**, snapped to one of **[24, 32, 40, 48, 56, 64]**, and **shared across all inventory grids**. No one should change sizes for "visual tweaks".
* **Seven equipment slots only:** `backpack`, `upper_body`, `lower_body`, `melee`, `handgun`, `long_gun`, `flashlight`.
* **Backpacks vs specialty containers:** Backpacks **only open when equipped**. Specialty containers (lunchbox, toolbox, etc.) may open inline **even when nested** inside other containers.
* **Order of operations matters:** Save/Load and context initialization must respect ordering to avoid React state races.
* **Dev-console‑driven validation:** Every phase includes specific console checks before merging.

---

## 2) Terminology

* **Item Definition (defId):** The blueprint describing size (w×h in slots), traits, weight, stack rules, and whether it is a container.
* **Item Instance (itemId):** A concrete instance with quantity, durability, and possibly a `containerId` if it’s a container item.
* **Container:** A grid that can hold item instances; includes ground, backpacks, and specialty containers.
* **Equipment slot:** A reserved place on the character UI (e.g., `backpack`, `melee`).
* **Grid Slot Size:** Pixel size of one inventory grid cell; fixed once per session.

---

## 3) Data model (reference shape)

> The exact interfaces may vary in code; treat this as a compatibility contract used by UI/contexts.

```ts
// Core types (reference)
export type ContainerId = string;     // Stable ID for any container (ground, backpack, lunchbox...)
export type ItemId = string;          // Stable per-instance identifier

export interface ItemDef {
  defId: string;
  name: string;
  size: { w: number; h: number };      // in grid slots
  stackable?: boolean;
  maxStack?: number;                    // if stackable
  weight?: number;                      // per unit or per item
  encumbrance?: { evade?: number; ap?: number };
  isContainer?: boolean;
  containerSize?: { w: number; h: number } | null; // interior grid if container
  openableWhenNested?: boolean;         // true for specialty containers; false for backpacks
}

export interface ItemInstance {
  itemId: ItemId;
  defId: string;                        // links to ItemDef
  qty?: number;                         // for stackable items
  containerId?: ContainerId | null;     // if this item IS a container, its interior grid id
}

export interface ContainerGrid {
  containerId: ContainerId;
  size: { w: number; h: number };
  items: Array<{
    itemId: ItemId;
    pos: { x: number; y: number };      // top-left pos in grid slots
  }>
}
```

**Ground** is modeled as a container grid. Equipment `backpack` slot references the **equipped backpack item**; the **backpack’s interior** uses its own `containerId`.

---

## 4) InventoryContext API (required surface)

> The UI and dev console rely on these methods; implement them by delegating to `InventoryManager` internals.

```ts
// Read
getContainer(containerId: ContainerId): ContainerGrid | null;
getEquippedBackpackContainerId(): ContainerId | null;     // returns the interior grid id of the equipped backpack
getEncumbranceModifiers(): { evade?: number; ap?: number };
openableWhenNested(itemOrDefId: ItemId | string): boolean; // true for specialty containers

// Mutations
equipBackpack(itemIdOrInstance: ItemId | ItemInstance): { ok: true } | { ok: false; reason: string };
moveItem(params: {
  fromContainerId: ContainerId;
  toContainerId: ContainerId;
  fromPos: { x: number; y: number } | null;  // null if moving from equipment or spawn
  toPos: { x: number; y: number };
  qty?: number;                               // for stacks; default all
}): { ok: true } | { ok: false; reason: string };
```

**Behavioral notes:**

* `getContainer` returns a **pure snapshot** suitable for rendering.
* `equipBackpack` verifies the item is a backpack, assigns it to the `backpack` slot, and initializes/links its interior container if needed.
* `moveItem` performs collision checks, stack merging (if same defId and stackable), and rejects if out-of-bounds or overlapping. It must leave both source and target containers valid.
* `openableWhenNested` returns **false** for backpacks, **true** for allowed specialty containers.

---

## 5) Grid size contract (non‑negotiable)

* Compute a **single** global slot size at startup.
* **Snap** the initial computed value to the nearest of `[24, 32, 40, 48, 56, 64]`.
* Expose via `GridSizeContext`: `{ fixedSlotSize, scalableSlotSize }`.
* **All** inventory UIs read `fixedSlotSize`. Do not recalc on window resize (unless a dev‑only manual action).

---

## 6) Equipment slots (authoritative list)

Exactly these seven in this order (UI can display in columns/rows as desired):

1. `backpack`
2. `upper_body`
3. `lower_body`
4. `melee`
5. `handgun`
6. `long_gun`
7. `flashlight`

**Do not** add, remove, or rename without a design update.

---

## 7) UI wiring (minimal, phase‑by‑phase)

### 7.1 Backpack display

* Equipment panel renders a **Backpack** slot.
* When a backpack is equipped, clicking the slot toggles a **backpack panel**.
* The panel renders `<ContainerGrid containerId={getEquippedBackpackContainerId()}>`.

### 7.2 ContainerGrid rules

* Uses `GridSizeContext.fixedSlotSize` for drawing tiles/slots.
* Drag‑drop or click‑to‑move calls `InventoryContext.moveItem(...)`.
* No grid size, CSS, or layout changes as part of inventory tasks.

### 7.3 Specialty containers

* Clicking an item whose def has `openableWhenNested: true` opens a small **inline floating panel** showing that item’s `containerId` grid.
* Backpacks **never** open inline unless equipped via the main slot.

---

## 8) Interaction rules

* **Placement:** Items occupy rectangular regions of size `def.size.w × def.size.h` in slots.
* **Collision:** No overlaps; out‑of‑bounds is rejected.
* **Stacking:** If target cell contains the **same** `defId` and is stackable, merge up to `maxStack`; remainder stays in source.
* **Splitting:** `qty` in `moveItem` splits a stack. If unspecified, move the entire stack.
* **Encumbrance:** `getEncumbranceModifiers()` reflects current equipped clothing; Player stats apply these numbers additively.
* **Undo safety:** Failing `moveItem` must be a **no‑op**; partial moves are forbidden.

---

## 9) Save / Load ordering

1. Initialize world and player baseline.
2. Initialize inventory manager.
3. **Restore inventory state** (containers, equipped slots).
4. Emit ready signals for UI to render.

Restoring earlier than player/world may cause components to read stale/empty context values.

---

## 10) Developer console: test matrix

> Use these scripted checks before merging any phase.

### A. Grid size discipline

* Start game → resize window → verify all inventory grids keep the **same** slot size.

### B. Equipment slots correctness

* UI lists exactly the seven slots; no helmet/vest/etc.

### C. Backpack wiring

* Seed a backpack item on ground.
* Pick up and call `equipBackpack(id)` → expect success.
* Click backpack slot → expect panel opens with a grid.
* Unequip/hide → panel disappears.

### D. Ground ↔ backpack moves

* Place a few items on ground.
* Drag or command‑move into backpack; then back to ground.
* Try an illegal overlap → expect rejection with a reason.

### E. Specialty container inline open

* Put a lunchbox inside the backpack.
* Click lunchbox → inline panel opens its grid.
* Verify backpack does **not** inline‑open.

### F. Save/Load

* Save with items in multiple containers and an equipped backpack.
* Reload → verify identical container contents and equipped state.

### G. Encumbrance

* Equip clothing with encumbrance values.
* Verify Evade/AP adjust; removing restores baseline.

---

## 11) Agent/Assistant guardrails (paste at top of a task)

```
Task: <phase title>
Files you may change: <whitelist paths>
You must NOT change: grid sizes/CSS/layout, equipment slot definitions, or files not listed above.
Hard rules:
  • Use exactly these equipment slots: backpack, upper_body, lower_body, melee, handgun, long_gun, flashlight.
  • Do not change grid sizes. Use GridSizeContext.fixedSlotSize.
  • Backpacks open only when equipped; specialty containers may open when nested.
Acceptance checklist: <bullets from the current phase>
If you hit scope creep or inter-system coupling, stop and ask.
```

---

## 12) Reference phase plan (short form)

1. **Lock global slot size.** One-time snap; no resize drift.
2. **Fix equipment slots.** Replace placeholder list with the seven canonical slots.
3. **Complete `InventoryContext` API.** Add `equipBackpack`, `getEquippedBackpackContainerId`, `getContainer`, `moveItem`, `openableWhenNested`.
4. **Backpack UI toggle.** Show backpack grid only when equipped.
5. **Ground ↔ backpack moves.** Wire `moveItem` to grid interactions.
6. **Inline specialty containers.** Open nested containers that allow it.
7. **Save/Load inventory.** Restore after world/player.
8. **Encumbrance → Player stats.** Apply modifiers.

---

## 13) Anti‑regression checklist

* [ ] Grid size stays constant post‑resize.
* [ ] No non‑spec equipment slots appear.
* [ ] Backpack panel only opens when a backpack is equipped.
* [ ] `moveItem` rejects overlaps and out‑of‑bounds without side effects.
* [ ] Nested specialty containers open inline; backpacks do not.
* [ ] Save/Load fully restores containers and equipment.
* [ ] Encumbrance correctly alters Evade/AP and reverts on removal.

---

## 14) Future enhancements (out of scope for the wiring pass)

* Shift‑click quick‑move rules and priorities.
* Auto‑arrange/pack algorithm for containers.
* Tooltip details (weight/size/encumbrance) and compare‑on‑hover.
* Drag‑ghost previews for collisions.
* Accessibility: focus model and keyboard placement.

---

**End of document.**
