Please always refer universalgoals.md and the current statemachineproject.md. Particularly the usegame() migration section. During phase 2 of gradual migration map transition has malfunctioned. The player is spawning at the top of the new map instead of the bottom. A generic object is spawning into the player's correct position at the bottom of the map. It seems that the map transition system has not been properly migrated. It's not accessing what it needs to access properly. It seems to have 2 different player refs. Maybe one is coming from the old way of doing things. Please check this thoroughly. Previous solutions have had no effect. Make sure those previous solutions haven't tangled things further. The following is your previous solution which did not work: 

Looking at the map transition issue, I can see the problem. During Phase 2 migration, the map transition system is indeed dealing with conflicting player references and isn't properly integrated with the new context architecture.

The issue is in the executeMapTransition function in GameMapContext.jsx. It's trying to manipulate player position directly, but during Phase 2 migration, the player data flows through PlayerContext, and the GameMapContext doesn't have the proper methods to update the player's position correctly.

Here's what's happening:

The transition tries to update player.x and player.y directly
But the PlayerContext manages the actual player state
The GameMap operations are working with a stale player reference
This creates a disconnect where the map thinks the player is in one place, but the contexts think they're elsewhere
The solution is to properly integrate the map transition with the Phase 2 architecture by ensuring the PlayerContext methods are used for player position updates.

client/src/contexts/GameMapContext.jsx
Now we need to add a position setter method to PlayerContext and update the GameContext wrapper:

client/src/contexts/PlayerContext.jsx
Now update the GameContext wrapper to pass the setPlayerPosition method:

client/src/contexts/GameContext.jsx
The problem was that the map transition system wasn't properly integrated with the Phase 2 architecture. The PlayerContext manages player state, but the map transition was directly manipulating player coordinates without going through the proper context methods. This created conflicting player references where the map thought the player was in one location while the contexts had different information.

The fix:

Added a setPlayerPosition method to PlayerContext for proper player position updates
Updated the executeMapTransition function to use this method
Modified the GameContext wrapper to pass the position setter to map transitions
This ensures all player position changes go through the PlayerContext, maintaining consistency across the Phase 2 architecture.
