“Just use CameraContext directly” (inside GameMapContext).
That re-introduces cross-context coupling. Keep Phase-4’s rule: single-concern contexts; orchestration happens in a thin layer (GameContext) or via an event/command bus. Don’t have contexts import each other.

“Circular dependency risk” => replace with events immediately.
The current wrapper in GameContext is acceptable for Phase-4. Move to a small event/command bus in Phase-5, not now. (Ripping wrappers mid-Phase-4 will slow you down and create churn.)

Parameter drilling diagnosis is right; prescription should be “bus/wrapper,” not “lookups everywhere.”
Using context lookups inside lower layers can silently re-tighten coupling. Prefer:

UI → command (with minimal payload)

Orchestrator/bus → calls the right systems.

Concrete next steps (what I’d do now)
Finish Phase-4 (1–2 days of focused work)

Migrate remaining components off useGame():

GameControls.tsx, DevConsole.jsx, StartMenu.tsx.

Import only what each needs from usePlayer, useGameMap, useCamera.

Keep GameContext as a thin orchestrator (no business logic).

Stabilize context outputs:

For each context, expose refs for large mutable structures (maps, player, camera) plus a small version token.

In useMemo/useCallback, depend on version, not .current.

Example:

const value = useMemo(() => ({
  gameMapRef,
  mapVersion,
  handleTileClick, // stable
}), [mapVersion]); // ❌ do not include gameMapRef.current


Normalize the map transition API:

Keep GameMapContext.handleMapTransitionConfirm(player, ops) stable.

Wrapper in GameContext gathers playerRef.current and camera ops and calls it—no UI component should pass 6–8 params anymore.

Ensure the post-transition re-save uses result.mapId || worldManager.currentMapId (you already fixed this).

Save/Load invariants (quick assertions):

On save: worldManager.currentMapId must be non-null and present in worldManager.maps.

On load (order matters):
worldManager = fromJSON → set currentMapId → setGameMap(worldManager.getCurrentMap()) → place player → set camera → bump mapVersion.

Add a tiny dev assertion logger if any of those fail.

Phase-5 prep (don’t do until Phase-4 is green)

Introduce a tiny command/event bus (cross-context):

Commands: PLAYER.MOVE_REQUEST, WORLD.TRANSITION_CONFIRMED, CAMERA.CENTER_ON.

GameContext subscribes and routes to the right context/system.

This removes the confirm→wrapper→context chain without creating context imports.

Selective subscriptions & perf:

MapCanvas renders should depend on mapVersion, cameraVersion, and playerRenderTick only.

Throttle FOV recompute during animation; recompute on animation end or at coarse intervals.

Error boundaries & debug:

Context-scoped error boundaries (Phase-5 asks for it).

Gate verbose logs behind DEBUG flag; keep structural logs (transition/saves) on.

Quick acceptance checklist

Phase-4 complete when:

No component imports useGame() except for reading isInitialized.

All context values are stable (no .current in dep arrays).

Map transition confirm is a single call from UI; wrapper prepares params.

Save → Load restores to the same map id, same player tile, and camera centers without jumps.

Phase-5 entry criteria:

No red console errors in transitions or saves.

Full round-trip save/load on both map_001 and map_002 passes 3 times consecutively.

South/north (and later east/west) reciprocal transitions are stamped and persisted.

Tiny code nudges (safe to apply anytime)

Dep arrays: Replace any useMemo/useCallback deps that include .current with the version token you already maintain.

WorldManager logging: Fix the “map_002 -> map_002” message by logging before you mutate currentMapId.

DevConsole: Stop reading aggregated gameInstance; read specific sub-contexts.