1) InventoryContext: immutable state + robust container resolution
A) Make openContainer immutable and accept object or id
// InventoryContext.jsx
- const openContainer = (containerId) => {
-   openContainers.add(containerId);
-   setOpenContainers(openContainers);
- };

+ // Accept either a container object or an id
+ const openContainer = (containerOrId) => {
+   const cid = typeof containerOrId === 'string'
+     ? containerOrId
+     : containerOrId?.id;
+   if (!cid) {
+     if (import.meta?.env?.DEV) console.warn('[Inventory] openContainer called without valid id');
+     return;
+   }
+   setOpenContainers(prev => {
+     const next = new Set(prev);
+     next.add(cid);
+     return next;
+   });
+ };

B) Same for closeContainer
- const closeContainer = (containerId) => {
-   openContainers.delete(containerId);
-   setOpenContainers(openContainers);
- };

+ const closeContainer = (containerId) => {
+   setOpenContainers(prev => {
+     const next = new Set(prev);
+     next.delete(containerId);
+     return next;
+   });
+ };

C) Add a resolver that finds containers not registered in manager
// still in InventoryContext.jsx
+ const resolveContainer = (containerId) => {
+   if (!containerId) return null;
+   // 1) Manager registry first
+   const fromMgr = manager?.getContainer?.(containerId);
+   if (fromMgr) return fromMgr;
+   // 2) Fall back: search ground items for a container with this id
+   try {
+     const ground = manager?.getContainer?.('ground');
+     if (ground?.items) {
+       for (const it of ground.items) {
+         const g = it?.getContainerGrid?.();
+         if (g?.id === containerId) return g;
+       }
+     }
+   } catch {}
+   return null;
+ };

D) Expose these on context value
- value: { ..., openContainers, openContainer, closeContainer }
+ value: { ..., openContainers, openContainer, closeContainer, resolveContainer }


Why: fixes (1) immutable updates and (2) ID lookup mismatch for ground containers.

2) UniversalGrid: await the container, pass the object (not just id)
// UniversalGrid.tsx
- const handleItemClick = (item) => {
-   if (canOpenContainer(item)) {
-     const container = item.getContainerGrid(); // may be Promise or null
-     if (container) openContainer(container.id);
-     else console.debug('[UniversalGrid] Missing container grid for', item.name);
-   } else {
-     console.debug('[UniversalGrid] Item cannot be opened inline:', item.name);
-   }
- };

+ const handleItemClick = async (item) => {
+   if (!canOpenContainer(item)) {
+     if (import.meta?.env?.DEV) console.debug('[UniversalGrid] Not openable:', item?.name);
+     return;
+   }
+   let grid = item.getContainerGrid?.();
+   if (grid && typeof grid.then === 'function') {
+     try { grid = await grid; } catch { grid = null; }
+   }
+   if (!grid) {
+     if (import.meta?.env?.DEV) console.warn('[UniversalGrid] No container grid for', item?.name);
+     return;
+   }
+   openContainer(grid); // pass the object; context extracts id
+ };


Why: fixes (4) async/await issue and ensures we pass a concrete container reference.

3) FloatingContainer: resolve + loud diagnostics + safe defaults
// FloatingContainer.tsx
-import { useInventory } from '@/contexts/InventoryContext';
+import { useInventory } from '@/contexts/InventoryContext';

 export default function FloatingContainer({ containerId }) {
   const { resolveContainer, closeContainer } = useInventory();
-  const container = resolveContainer(containerId);
+  const container = resolveContainer?.(containerId);

+  if (!container) {
+    if (import.meta?.env?.DEV) {
+      console.warn('[FloatingContainer] Container not resolved:', containerId);
+    }
+    return null;
+  }

   // Ensure visible by default near top-left but within viewport
-  return (
-    <div className="fixed z-50 ...">
+  return (
+    <div className="fixed z-[9999] left-8 top-8 max-h-[70vh] max-w-[40vw] shadow-lg rounded-lg overflow-hidden">
       {/* header + ContainerGrid render here */}
     </div>
   );
 }


Why: if resolution fails, you see it in the console; and default position can’t be off-screen. Keeping z-[9999] matches your DevConsole layer.

4) InventoryPanel: map openContainers → panels (no double portals)

Make sure you don’t wrap FloatingContainer in another createPortal here—FloatingContainer already portals to document.body (per your last change).

// InventoryPanel.tsx
- {Array.from(openContainers).map(id => createPortal(<FloatingContainer key={id} containerId={id} />, document.body))}
+ {Array.from(openContainers).map(id => (
+    <FloatingContainer key={id} containerId={id} />
+ ))}


Why: prevents the “double-portal” no-op you ran into earlier.

5) Quick debug toggles (optional but helpful)

Add a ?invdebug query toggle to see what the system thinks is open:

// InventoryPanel.tsx (or a small DebugFloatingContainers.tsx)
+ const debug = typeof window !== 'undefined' && new URLSearchParams(location.search).has('invdebug');
+ {debug && (
+   <div className="fixed bottom-2 right-2 z-[9999] text-xs bg-black/70 text-white px-2 py-1 rounded">
+     openContainers: {Array.from(openContainers).join(', ') || '∅'}
+   </div>
+ )}

Acceptance (manual, in-game console; no hot reloads)

Spawn a small container on ground (from your defs):

const { Item } = await import('./game/inventory/Item.js');
const { createItemFromDef } = await import('./game/inventory/ItemDefs.js');
const lunch = new Item(createItemFromDef('container.lunchbox')); // adjust def id
window.inventoryManager.getContainer('ground').addItem(lunch, 0, 0); // coords as needed


Click the lunchbox in GroundItemsGrid.
Expect: openContainers shows its id (add ?invdebug to confirm), a panel appears at top-left, and logs show neither “not resolved” nor “not openable”.

Click a backpack item on ground.
Expect: log “Not openable” (per your rules).

Move the lunchbox or unequip the backpack.
Expect: panel persists until closed; or auto-closes if you already wired the “container no longer exists → close panel” effect (that can be added later per 5F).

Why this works (and why prior fixes didn’t)

You now immutably update the open set → React re-renders.

You resolve container IDs even when they’re not registered under manager.containers (the usual case for ground items).

You await the container when needed, so openContainer gets a real object, not a Promise.

You render inside the InventoryProvider (for state) but portal out for z-index, avoiding stacking-context traps.

If you still see “no panel,” add two temporary console.logs:

In openContainer just before setOpenContainers, log the computed cid.

In FloatingContainer log both containerId and the resolved container.

Those two logs will pinpoint whether it’s (a) not adding to state, or (b) failing to resolve the container object.