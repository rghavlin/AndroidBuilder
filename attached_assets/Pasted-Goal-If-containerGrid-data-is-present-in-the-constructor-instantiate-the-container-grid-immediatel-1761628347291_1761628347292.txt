Goal: If containerGrid data is present in the constructor, instantiate the container grid immediately. No fire-and-forget async.

- // Item.js (constructor)
- if (this._containerGridData) {
-   // fire-and-forget
-   this.initializeContainerGrid().catch(err => console.warn('[Item] container init failed', err));
- }

+ // Item.js (constructor)
+ if (this._containerGridData) {
+   // Synchronous creation: no async, no race.
+   this.containerGrid = new ContainerGrid({
+     id: this._containerGridData.id || `${this.instanceId}-container`,
+     width: this._containerGridData.width,
+     height: this._containerGridData.height,
+     ownerItemId: this.instanceId
+   });
+}

- // Item.js
- async initializeContainerGrid() {
-   const { ContainerGrid } = await import('./ContainerGrid.js');
-   this.containerGrid = new ContainerGrid({ ...this._containerGridData, ownerItemId: this.instanceId });
- }
+ // If you keep initializeContainerGrid for rare lazy cases, make it a no-op when already created:
+ initializeContainerGrid() {
+   if (this.containerGrid) return;
+   this.containerGrid = new ContainerGrid({
+     id: this._containerGridData?.id || `${this.instanceId}-container`,
+     width: this._containerGridData?.width,
+     height: this._containerGridData?.height,
+     ownerItemId: this.instanceId
+   });
+ }

- // Item.js
- getContainerGrid() {
-   if (!this.containerGrid && this._containerGridData) {
-     // kick async init and return null
-     this.initializeContainerGrid();
-     return null;
-   }
-   return this.containerGrid || null;
- }
+ getContainerGrid() {
+   // Already created synchronously when data was present.
+   return this.containerGrid || null;
+ }


If you hit a circular import: move ContainerGrid to a tiny dependency-free module (e.g., ContainerGridCore.js) or inject a creator:

In Item.js, import createContainerGrid from a small factory file that only exports a class literal.

Replace new ContainerGrid(...) with createContainerGrid({...}).

2) Remove the dynamic import at the top of Item.js (if present)

No await import('./ContainerGrid.js') in the constructor path. Keep imports static, or use the factory pattern above.

3) (Belt & suspenders) In InventoryManager.updateDynamicContainers

If you currently do:

const grid = item.getContainerGrid();
if (grid) this.containers.set(grid.id, grid);


that’s fine—after the sync change, grid will be there.
Optionally add a one-time warn if grid is missing (shouldn’t happen anymore):

if (!grid) console.warn('[Inventory] containerGrid missing for equipped item', item.instanceId);

Acceptance (Phase 5C)

In-game console:

const { Item } = await import("./game/inventory/Item.js");
const bp = new Item({
  instanceId:"bp1",
  defId:"container.backpack",
  name:"Test Backpack",
  width:3, height:4,
  equippableSlot:"backpack",
  containerGrid:{ width:8, height:10 },
  traits:["equippable","container"]
});
window.inventoryManager.equipItem(bp, "backpack");


Expected now:

window.inventoryManager.getEquippedBackpackContainer() (or your helper) returns a grid immediately.

BackpackGrid renders the 8×10 container on equip; placeholder returns when unequipped.

Slot pixel size matches ground grid (unchanged; both use GridSizeContext).