What’s happening now is a control-flow regression around initialization, not an inventory bug. Here’s the shortest path back to “click once → game starts” plus guardrails to keep it that way.

What’s going on (from your code)

StartMenu → New Game calls your handler, which calls initializeGame(false, 'autosave', true) (note the third arg)【turn47file5†codebase.txt†L67-L71】【turn47file3†codebase.txt†L83-L91】.

GameScreenContent has a re-entry gate that bails if the game is already ready; that’s why your later clicks do nothing when isGameReady is true【turn47file3†codebase.txt†L59-L66】【turn47file3†codebase.txt†L88-L95】.

GameContext creates a GameInitializationManager as soon as the provider mounts (good), wires listeners (good), but doesn’t show the initializeGame body here; the provider is intended to be the only orchestration surface【turn47file4†codebase.txt†L74-L87】【turn47file2†codebase.txt†L68-L70】.

MapInterface: your plan doc shows the auto-init effect was removed; only the Start Menu should call initializeGame【turn47file4†codebase.txt†L11-L21】【turn47file9†codebase.txt†L40-L47】.

Game.tsx provider order is stable (Camera→GameMap→Player→Game)【turn47file11†codebase.txt†L10-L19】.

The symptom you pasted (“StartMenu… Ignoring start game – already initializing or ready”) means by the time you click, isGameReady is already true (i.e., something started and completed init ahead of your click) or your idempotency guard in initializeGame() is blocking re-entry after a previous run due to stale React state reads. Your Start Menu check then short-circuits.

The safe fix is to (1) guarantee only the Start Menu kicks off init, and (2) make initializeGame() use ref-based guards so it never reads stale state and can intentionally reset for a “New Game”.

Fix (surgical, agent-ready)
1) Keep a single, passive manager on mount (already true)

GameContext should create the manager on mount but never start it automatically. You already do the creation+listener wiring in a useEffect【turn47file4†codebase.txt†L74-L87】. Leave that as-is.

2) Ref-based idempotency (replace closure checks)

In GameContext.jsx, add a ref mirror for the init state and a run id:

// top-level in GameContextInner
const [initializationState, setInitializationState] = useState<'idle'|'preloading'|'core_setup'|'world_population'|'complete'|'error'>('idle');
const initStateRef = useRef(initializationState);
useEffect(() => { initStateRef.current = initializationState }, [initializationState]);

const runIdRef = useRef(0); // increments for each fresh run


Then implement initializeGame so it reads initStateRef and supports an explicit reset when the 3rd arg is true (as you already pass from GameScreen):

const initializeGame = useCallback(async (loadAfter = false, slot = 'autosave', explicitNewGame = false) => {
  const stateNow = initStateRef.current;

  // Allow explicit fresh runs from complete/error by resetting state & listeners
  if (explicitNewGame && (stateNow === 'complete' || stateNow === 'error')) {
    runIdRef.current += 1;
    setIsGameReady(false);
    setInitializationError(null);
    setInitializationState('idle');
    setContextSyncPhase('idle');

    // optional: dispose and recreate manager to avoid zombie listeners
    initManagerRef.current?.dispose?.();
    initManagerRef.current = new GameInitializationManager();
    wireManagerEvents(initManagerRef.current, runIdRef.current); // same wiring function you use now
  }

  // Gate concurrent starts (reads current state from ref, never stale)
  if (initStateRef.current !== 'idle') {
    console.log('[GameContext] initializeGame ignored; state:', initStateRef.current);
    return;
  }

  console.log('[GameContext] Starting game initialization via state machine...');
  setInitializationState('preloading'); // optimistic lock to prevent double starts

  // Kick off the manager (your existing method)
  await initManagerRef.current.startInitialization(loadAfter, slot, runIdRef.current);
}, []);


Also tweak your event listeners wiring so they ignore out-of-date runs:

function wireManagerEvents(manager, runId) {
  manager.on('stateChanged', (nextState, evtRunId) => {
    if (evtRunId !== runIdRef.current) return; // ignore stale events
    setInitializationState(nextState);
  });
  manager.on('initializationComplete', (evtRunId) => {
    if (evtRunId !== runIdRef.current) return;
    setIsGameReady(true);
  });
  manager.on('initializationError', (err, evtRunId) => {
    if (evtRunId !== runIdRef.current) return;
    setInitializationError(err);
  });
}


If your manager doesn’t emit a runId, just close over the active runId when you attach listeners and compare to runIdRef.current before setting state.

3) Keep the Start Menu gate (already correct)

Your GameScreenContent guard is good; it blocks re-entry and hides the menu after init starts【turn47file3†codebase.txt†L83-L91】. Keep this exactly as you have it.

4) Verify there’s no other caller

You recorded the rule in your doc: the Start Menu must be the only caller of initializeGame()【turn47file4†codebase.txt†L52-L56】. With the above ref-based guard, even a stray call can’t race a legitimate click.

“Back to normal” acceptance checklist

Load app → Start Menu visible; no state machine runs (no preloading log).

Click “New Game” once → see preloading in the log, then sequence to complete; menu hides after init starts【turn47file4†codebase.txt†L21-L35】.

Click “New Game” again from the Start Menu (after returning to it) → a fresh run starts because explicitNewGame resets the state via the ref-based implementation above.

Grep shows no other initializeGame( call sites beyond Start Menu handler (your plan explicitly calls this out)【turn47file4†codebase.txt†L52-L56】.

Why this went off the rails (so it doesn’t happen again)

Stale state in async guards. Using if (initializationState !== 'idle') inside initializeGame reads a captured value from a prior render, so the guard misfires. Always mirror such state into a ref before guarding.

Two sources of truth. Auto-init from a component effect + Start Menu click created racey behavior. Lock it to Start Menu only.

Zombie events. Listeners from a previous run can still fire after a reset. Add a runId gate so late events from a prior run are ignored.

Minimal diff summary (commit-sized)

GameContext.jsx

Add initStateRef, runIdRef.

Replace initializeGame with ref-based guard + optional explicit reset (as above).

Extract/wrap your manager event wiring in wireManagerEvents(manager, runId) that guards by runIdRef.current.

Verify MapInterface.tsx no longer auto-calls initializeGame (your current file should be display-only; acceptance: “No other code path calls initializeGame()”)【turn47file4†codebase.txt†L52-L56】.

No changes to grid, inventory, or slot visuals.

Quick sanity checks (use your in-game console)

status init (or a small dev command you already expose) should show idle on the Start Menu.

Click “New Game” → preloading appears immediately and proceeds.

After complete, run your inventory console demos (now moved in-game) to be sure no hot-reload path is re-triggering init.