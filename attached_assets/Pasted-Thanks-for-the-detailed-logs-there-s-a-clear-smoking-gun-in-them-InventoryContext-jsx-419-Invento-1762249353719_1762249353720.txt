Thanks for the detailed logs—there’s a clear smoking gun in them:

InventoryContext.jsx:419 [InventoryContext] Creating new context value - dragVersion: 1 dragState: {…}
immediately followed by
InventoryContext.jsx:419 [InventoryContext] Creating new context value - dragVersion: 2 dragState: null

That pattern almost never comes from “image didn’t load” or “mousemove not fired.” It means the drag state is being set, then read as null by a different InventoryContext instance (or a freshly remounted one). In practice, the grids (overlay highlight) are reading Provider A (which has the item), while DragPreviewLayer is reading Provider B (which is null). That’s why the item “vanishes” and only the placement highlight works.

Here’s how to fix it decisively:

1) Ensure there is exactly one InventoryProvider

You already wrap the game with <InventoryProvider> inside GameContext.jsx. Remove any other <InventoryProvider> or InventoryContext.Provider wrappers (common culprits are InventoryPanel, InventoryOverlay, or a sidebar/modal).

Don’t conditionally mount the provider (e.g., behind inventoryOpen ? <Provider>…). Mount it once, high in the tree (e.g., around GameScreen), and keep it mounted.

Quick way to catch duplicates (add and keep temporarily)

In client/src/contexts/InventoryContext.jsx, right after the component starts:

// TEMP DIAGNOSTIC
const __instanceId = Math.random().toString(36).slice(2,7);
useEffect(() => {
  console.log(`[InventoryContext] MOUNT id=${__instanceId}`);
  return () => console.log(`[InventoryContext] UNMOUNT id=${__instanceId}`);
}, []);


When you click an item, you should not see multiple MOUNTs or an UNMOUNT/MOUNT cycle. If you do, you’ve still got duplicate/mount churn.

2) Make sure DragPreviewLayer consumes the same provider

Keep DragPreviewLayer under the same React tree as the single provider. If you render it via a portal, that’s fine—portals preserve context—but the component doing createPortal must itself be under the provider.

If DragPreviewLayer was inside a component that had its own provider (even accidentally), move it out so it reads the top-level one.

3) Don’t cancel drag on “leave” or remounts

In UniversalGrid.tsx, keep onMouseLeave limited to clearing hover/preview overlays. Do not call cancelDrag() there.

If you have any global mouseup/click listeners calling endDrag immediately, remove them (leave placement to an explicit left-click).

4) Make the preview bulletproof (small but important)

In DragPreviewLayer.tsx:

Give it position: fixed; pointer-events: none; z-index: 999999; so it never swallows mouse events and always floats above.

Track mouse on the window, not just inside the grid, so the preview follows everywhere:

useEffect(() => {
  function onMove(e: MouseEvent) {
    updateDragPosition(e.clientX, e.clientY);
  }
  window.addEventListener('mousemove', onMove);
  return () => window.removeEventListener('mousemove', onMove);
}, [updateDragPosition]);


Render immediately even if the item image isn’t loaded yet (show a simple placeholder rectangle using the item’s slot width/height). This removes any perceived “vanish” while images decode.

5) (Nice-to-have) Guard against accidental resets

Inside InventoryContext.jsx, if you have an effect that resets dragState when inventory changes, remove it. Drag should end only via explicit placeDrag, cancelDrag, or endDrag.

Why I’m confident this is the root cause

Your logs show the context value being created twice in sequence with different drag states—first with the item, then immediately as null. That’s classic duplicate-provider or remount behavior.

The grids continue to show valid placement overlays and allow click-to-place. That means one provider (the one the grids use) is fine. The preview layer is subscribed to the other one, which is null, hence “nothing sticks to the cursor.”

Separate note on this console line (not related to the cursor)
[InventoryManager] Container not found: {fromContainerId: 'ground', toContainerId: 'toolbox-...-container'}


This is a dev-console move trying to target a nested container id that doesn’t exist in the active InventoryManager. It’s unrelated to the preview issue above; fix it later by using the actual container id (item.getContainerGrid()?.id) rather than a constructed -container suffix.