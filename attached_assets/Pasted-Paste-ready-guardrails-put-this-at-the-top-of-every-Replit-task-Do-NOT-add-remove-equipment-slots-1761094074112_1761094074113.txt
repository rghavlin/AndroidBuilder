Paste-ready guardrails (put this at the top of every Replit task)

Do NOT add/remove equipment slots. Allowed exactly: backpack, upper_body, lower_body, melee, handgun, long_gun, flashlight.

Do NOT change grid sizing, CSS, or GridSizeContext. Global slot size is picked once at startup, snapped to [24,32,40,48,56,64], and shared across all grids.

Backpacks open only when equipped. Specialty containers open even when nested.

Scope of changes is confined to: src/systems/inventory/*, src/contexts/InventoryContext.*, src/contexts/GameContext.* (save/load only), and src/components/Inventory/EquipmentSlot.* (backpack wiring only). No new buttons or layout wrappers; minimal diffs.

Universal “red flags” to stop/ask: adding features not requested, cross-system tight coupling, and skipping console/demo tests.

Incremental plan (each phase is a single focused PR)
Phase 0 — Lock the global slot size (no visual change)

Goal: Enforce “pick once, snap, and share” behavior for slot size.

Files allowed: hooks/useGridSlotSize.*, contexts/GridSizeContext.*

Do not touch: Any CSS, map tile sizes, or inventory layout.

Work:

In useGridSlotSize, compute once on first mount: snap the computed size to the nearest of [24,32,40,48,56,64], store it in state, and never recompute on resize (unless a manual “recalc” is explicitly invoked in dev only).

Keep GridSizeProvider mirroring scalable→fixed so all grids match.

Acceptance (dev console): Start game → resize window → inventory slot size remains unchanged; backpack/ground/specialty grids render at the identical size.

Commit title: infra(grid): one-time snapped global slot size

Phase 1 — Fix equipment slot list (UI only)

Goal: Replace the placeholder equipment chips with the spec’d seven.

Files allowed: components/Inventory/EquipmentSlots.tsx

Do not touch: Styles, layout, drag/drop, any grid code.

Work: Replace the hardcoded list (helmet/vest/…) with [backpack, upper_body, lower_body, melee, handgun, long_gun, flashlight].

Acceptance: The UI shows exactly those seven slots—no extras, consistent test IDs (e.g., data-testid="equipment-slot-backpack").

Commit title: ui(inventory): correct equipment slots per spec

Phase 2 — Finish InventoryContext API

Goal: Provide the wiring surface the UI needs, matching the design plan.

Files allowed: contexts/InventoryContext.jsx, systems/inventory/*

Do not touch: Components or CSS.

Work: Add and export:

equipBackpack(itemIdOrInstance)

getEquippedBackpackContainerId()

getContainer(containerId)

moveItem({fromContainerId, toContainerId, fromPos, toPos, qty})

openableWhenNested(itemOrDefId)
These should wrap existing InventoryManager methods as available. Today we already expose getEquippedBackpackContainer, getEncumbranceModifiers, canOpenContainer; keep them.

Acceptance (dev console): Using the existing “inventory system” test hooks:

Seed a backpack → equipBackpack(...) returns success.

getEquippedBackpackContainerId() returns a stable id.

moveItem(...) moves an item ground↔backpack with no UI required.

Commit title: feat(inventory): complete InventoryContext surface

Phase 3 — Minimal UI wiring: show backpack grid only when equipped

Goal: Render <ContainerGrid containerId={equippedId}> only when backpack is equipped—no CSS/layout changes.

Files allowed: components/Inventory/* (only the container grid and the minimal hook-up), contexts/InventoryContext.*

Do not touch: Grid size code, general layout, or extra UI chrome.

Work:

In the equipment panel, clicking the backpack slot toggles the backpack panel, but only if a backpack is equipped (no phantom grids).

<ContainerGrid> pulls its slot size from GridSizeContext.fixedSlotSize.

Acceptance: Equip backpack → a grid appears; unequip → grid hides.

Commit title: ui(inventory): backpack grid appears only when equipped

Phase 4 — Moves between ground and backpack (context ops only)

Goal: Enable ground ↔ backpack moves via context methods (no new UI widgets).

Files allowed: components/Inventory/ContainerGrid.*, systems/inventory/*, contexts/InventoryContext.*

Do not touch: Grid sizes, CSS, or map code.

Work: Wire grid interactions to call moveItem(...) on InventoryContext. Use the dev console to seed items on the ground and test moves.

Acceptance: Move one stack ground→backpack and back; no console errors; global slot size still identical across grids.

Commit title: feat(inventory): ground↔backpack moves via context

Phase 5 — Open specialty containers inline (even when nested)

Goal: Lunchbox/toolbox/etc. can open inline while inside other containers.

Files allowed: components/Inventory/FloatingContainer.tsx, components/Inventory/ContainerGrid.*, systems/inventory/*

Do not touch: Layout wrappers; no draggable windows beyond what exists.

Work: If openableWhenNested(item) is true, clicking the item opens an inline panel view of its container grid (closeable). Backpacks still only open when equipped.

Acceptance: A lunchbox inside a backpack opens; a backpack inside a backpack does not.

Commit title: feat(inventory): nested specialty containers open inline

Phase 6 — Save/Load inventory (after world/player)

Goal: Persist inventory per the Implementation Plan.

Files allowed: contexts/GameContext.* (save/load only), systems/inventory/*

Do not touch: Rendering, layout, or grid code.

Work: Include inventory JSON in saves; restore it after player/world init (ordering matters).

Acceptance: Save on map_002 with items, reload to the same map with the same items and the same equipped backpack container id.

Commit title: feat(save): persist inventory and equipped backpack

Phase 7 — Apply encumbrance to player stats

Goal: Hook getEncumbranceModifiers() into the player stats flow.

Files allowed: contexts/PlayerContext.*, contexts/InventoryContext.*

Do not touch: UI beyond numbers already displayed.

Work: Aggregate evade/AP deltas into PlayerContext as described.

Acceptance: Equipping/removing clothing modifies Evade/AP; removing reverts.

Commit title: feat(player): apply encumbrance modifiers

“Things we might overlook” checklist

Grid size drift: After Phase 0, window resizes must not change the chosen slot size; everything uses the shared fixed size.

Equipment slots regression: Keep tests/QA that assert the seven-slot list and block “helmet/vest/…” from returning.

Context race conditions: Avoid .current in hook dependency arrays (explicit QA rule).

Save/Load order: Inventory restore must come after world & player init, not before.

Electron vs web: When you touch assets or paths for inventory icons, follow the electron compatibility checklist and single-loader strategy.

Scope creep control: The universal guidelines call out “adding features not explicitly requested” as a red flag—keep PRs tiny and reversible.