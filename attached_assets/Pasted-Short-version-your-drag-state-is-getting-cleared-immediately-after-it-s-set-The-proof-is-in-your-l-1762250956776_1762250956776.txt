Short version: your drag state is getting cleared immediately after it’s set. The proof is in your logs:

Begin drag … setDragState … → Creating new context value - dragVersion: 1 …

Right away: Creating new context value - dragVersion: 2 dragState: null

Nothing in between (no cancel/place logs). That means some handler is calling your “clear/close” logic on the same click that started the drag (classic mousedown→click/mouseup bubble).

Also, you’re seeing two InventoryProvider MOUNT id=… lines at boot. That’s likely React StrictMode double-mount in dev and isn’t the mid-drag reset. The real problem is a parent onClick (or a document/global listener) that clears drag, or an onMouseUp that fires after onMouseDown started the drag.

Here’s a surgical fix that stops the “vanish on first click” without rewriting anything:

1) Guard clearDrag in InventoryContext.jsx

Make “clear” a reasoned action, and ignore accidental clears while an active drag is in progress.

// InventoryContext.jsx
- const [dragState, setDragState] = useState(null);
+ const [dragState, setDragState] = useState(null);
+ const dragActiveRef = useRef(false);

  const beginDrag = useCallback(({ item, originContainerId, originX, originY, initialCursorX, initialCursorY, rotation = 0 }) => {
    // remove from container etc…
-   setDragState({ item, originContainerId, originX, originY, cursorX: initialCursorX, cursorY: initialCursorY, rotation });
+   dragActiveRef.current = true;
+   setDragState({ item, originContainerId, originX, originY, cursorX: initialCursorX, cursorY: initialCursorY, rotation });
  }, [/* deps */]);

- const clearDrag = useCallback(() => setDragState(null), []);
+ const clearDrag = useCallback((reason = 'unknown', force = false) => {
+   // Only allow specific reasons while a drag is active
+   const allow = force || !dragActiveRef.current || reason === 'place' || reason === 'cancel' || reason === 'escape';
+   if (!allow) {
+     console.log('[InventoryContext] Ignored clearDrag during active drag:', reason);
+     return;
+   }
+   dragActiveRef.current = false;
+   setDragState(null);
+ }, []);

  const cancelDrag = useCallback(() => {
    // restore item to origin…
-   setDragState(null);
+   dragActiveRef.current = false;
+   setDragState(null);
  }, []);

  const tryPlaceDrag = useCallback((/* … */) => {
    // if success -> place and clear with reason 'place'
-   setDragState(null);
+   dragActiveRef.current = false;
+   setDragState(null);
  }, []);


Export and use clearDrag(reason) everywhere (no raw setDragState(null) outside the context).

2) Stop parent clicks from clearing right after start

Look for any panel/background/document handler that resets/clears selection/drag. Make two tweaks:

Background container: only clear when clicking the background, not a child.

- <div className="inventory-panel" onClick={() => clearDrag('bg-click')}>
+ <div
+   className="inventory-panel"
+   onMouseDown={(e) => {
+     if (dragState) return;            // don’t clear during an active drag
+     if (e.target === e.currentTarget) clearDrag('bg-click');
+   }}
+>


Document/global listeners: if you have a window.addEventListener('click'|'mouseup', … clear …), gate it:

if (!dragState) clearDrag('doc-click');

3) Start drag on pointerdown, suppress bubbling

This prevents the later click on the same element (or its parent) from firing a “clear”.

// UniversalGrid.tsx cell/item handlers
- const onItemMouseDown = (e, cellX, cellY, item) => {
+ const onItemPointerDown = (e, cellX, cellY, item) => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();           // <- crucial
    beginDrag({
      item, originContainerId: containerId, originX: cellX, originY: cellY,
      initialCursorX: e.clientX, initialCursorY: e.clientY,
      rotation: 0
    });
  };


Also ensure your grid background doesn’t have an onClick that runs after this and calls clearDrag (use the guarded version above if it must exist).

4) Right-click rotate should never bubble

If you rotate with onContextMenu, keep it local:

const onContextMenu = (e) => {
  if (!dragState) return;
  e.preventDefault();
  e.stopPropagation();
  rotateDrag();
};

5) DragPreviewLayer: always-on, fixed, pointer-events none

You already portaled it; double-check these details:

.preview {
  position: fixed;     /* not absolute */
  left: 0; top: 0;
  transform: translate(var(--cursor-x), var(--cursor-y));
  pointer-events: none;
  z-index: 9999;
}


Render even while the image is loading (show a placeholder), so you see the cursor follower immediately.

6) The dev-console “Container not found” line

toContainerId: 'toolbox-…-container' wasn’t registered. For nested moves, use the nested container grid id, not the parent item id. From your recent fixes that means:

// Good targets in console:
const tb = inv.findByName?.('Tool Box');          // however you fetch it
const nested = tb.getContainerGrid();             // returns a Container instance
inv.moveItem({ fromContainerId: 'ground', toContainerId: nested.id, ... });


If you only have the item, item._container?.id is the parent container the item sits in; item.getContainerGrid()?.id is the child/nested container to open/drop into. Use the latter for “drop into box”.

Why this fixes your exact symptom

Your logs show state set → immediately cleared. That’s a click/timing/bubbling issue, not missing images or portals. The guard in clearDrag, plus stopPropagation() on the drag start, stops the accidental clear on the same click.

If some other component must clear on background interaction, it won’t fire during active drag (unless you explicitly pass clearDrag('cancel'|'place')).

If you want me to pinpoint the exact caller doing the unwanted clear, add this one-liner in the context and scan the reasons:

const clearDrag = (reason='unknown', force=false) => {
  console.trace('[InventoryContext] clearDrag called:', reason);
  …
};


You’ll see precisely which handler is nuking the drag right after beginDrag.