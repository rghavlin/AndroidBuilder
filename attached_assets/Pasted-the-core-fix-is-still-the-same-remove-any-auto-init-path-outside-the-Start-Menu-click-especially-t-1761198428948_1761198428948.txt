the core fix is still the same: remove any auto-init path outside the Start Menu click, especially the useEffect(... initializeGame() ...) in MapInterface. That’s the thing that caused the one-time flicker + “second click starts” behavior. Do that, and you should be back to single-click start without touching grid/UI code.

Here’s the clean way to lock it down now:

What to keep (single initializer)

Start Menu button → initializeGame() is the only place that should kick off the state machine.

No auto-init in MapInterface, GameScreen, or any child mounting effects.

Don’t hide the menu until init has actually started. Either after initializeGame() resolves its first await or after you see state preloading.

Tiny, safe diffs (agent-ready)

A) Remove the stray auto-init (root cause)

In MapInterface.tsx, delete the useEffect that calls initializeGame() when it mounts (timer or not).

B) Gate the Start Menu, avoid re-entry

In GameScreen (or where handleStartGame lives):

const [isInitializing, setIsInitializing] = useState(false);

const handleStartGame = async () => {
  if (isInitializing || isGameReady || initializationError) return;
  setIsInitializing(true);

  try {
    await initializeGame();                // start the state machine
    setShowStartMenu(false);               // hide AFTER init starts
  } finally {
    setIsInitializing(false);
  }
};


If you prefer to keep the menu visible until you know init started, you can also hide it on the first state callback to preloading instead of immediately after the click.

C) Make initializeGame idempotent (belt & suspenders)

In GameContext, before kicking off the machine:

if (initState !== 'idle') return; // ignore stray calls


You already have guards against duplicate managers; add this simple gate to ignore a second trigger during the same run.

Acceptance checklist

Click New Game once → menu hides and the game initializes; no flicker and no second click needed.

No other code path calls initializeGame() (grep for it; only the Start Menu handler should remain).

If you log state transitions, you’ll see exactly one sequence (idle → preloading → core_setup → world_population → complete) per click.

HMR isn’t involved: if you add a temporary Vite HMR listener, you should not see [HMR] events when reproducing the issue.