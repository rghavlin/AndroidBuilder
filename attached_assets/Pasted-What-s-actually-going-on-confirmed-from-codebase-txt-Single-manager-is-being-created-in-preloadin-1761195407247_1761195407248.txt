What’s actually going on (confirmed from codebase.txt)

Single manager is being created in preloading (Phase 5A) and stored in gameObjects. You’re good there:

GameInitializationManager._executePreloading() does const inventoryManager = new InventoryManager(); and logs it.

InventoryProvider correctly takes an external manager and never constructs its own, and GameContext mounts it only after init sets inventoryManager in state.

Your dev-console bridge is gated by process.env.NODE_ENV === 'development', so on Replit it often never sets window.inventoryManager (this is why Replit shows it as undefined even though the instance exists).

The “one extra initialization” causing the Start Menu flicker is coming from MapInterface.tsx. It calls initializeGame() in a useEffect with a timer whenever it mounts and !isInitialized. When you click New Game, two initializations race:

GameScreenContent.handleStartGame() (the intended one)

MapInterface.useEffect(... initializeGame() ...) (the unintended one)

That double-trigger perfectly matches your symptom: first click flickers (dueling inits), second click works because state has settled.

Minimal, safe fixes (copy/paste this to the Replit agent)

Task: Eliminate double initialization & make the dev-console bridge work on Replit
Files you may change:

client/src/components/Game/MapInterface.tsx

client/src/contexts/InventoryContext.jsx
Do NOT change: camera math, grid sizes, layout, CSS, or any other initialization paths.

1) Remove the MapInterface auto-init (root cause of flicker)

Edit client/src/components/Game/MapInterface.tsx and delete the mount-time effect that calls initializeGame():

-  // Initialize game when component mounts
-  useEffect(() => {
-    if (!isInitialized && !initializationError) {
-      // Small delay to ensure provider is ready after hot reloads
-      const timer = setTimeout(() => {
-        console.log('[MapInterface] Initializing game...');
-        initializeGame();
-      }, 100);
-      return () => clearTimeout(timer);
-    }
-  }, [isInitialized, initializationError, initializeGame]);


Initialization should occur only via the Start Menu button (i.e., handleStartGame() in GameScreen).

2) Make window.inventoryManager available in Replit (QA only)

Edit client/src/contexts/InventoryContext.jsx and change the dev-bridge guard to a runtime window check so Replit gets the global:

-  useEffect(() => {
-    if (process.env.NODE_ENV === 'development' && inventoryRef.current) {
+  useEffect(() => {
+    if (typeof window !== 'undefined' && inventoryRef.current) {
       window.inventoryManager = inventoryRef.current;
       window.inv = {
         getContainer: (id) => inventoryRef.current?.getContainer(id),
         equipItem: (item, slot) => inventoryRef.current?.equipItem(item, slot),
         moveItem: (itemId, from, to, x, y) => inventoryRef.current?.moveItem(itemId, from, to, x, y),
       };
       console.log('[InventoryContext] Dev console bridge established: window.inventoryManager, window.inv');
     }
   }, []);


(If you want to keep it strictly dev-only, gate it behind a custom env var like VITE_DEBUG_INVENTORY_GLOBALS === 'true' instead.)

Acceptance (what you should see immediately)

Click New Game once → the game initializes (no flicker, no second click needed).

window.inventoryManager is defined; window.inventoryManager.getContainer('ground') returns a snapshot.

Ground grid shows (and stays) without any “no ground container available” message.

Slot pixel size remains unchanged across resizes (unchanged by these changes).

Extra check (if you’re worried about hidden hot reloads)

Drop this in a bootstrap module (e.g., the top of GameScreen.tsx) for a quick signal:

if (import.meta?.hot) {
  import.meta.hot.on('vite:beforeUpdate', (e) => console.log('[HMR] beforeUpdate', e.updates));
  import.meta.hot.on('vite:afterUpdate',  () => console.log('[HMR] afterUpdate'));
}


If you don’t see [HMR] logs while reproducing the flicker, it wasn’t hot reload—it was the double init above.