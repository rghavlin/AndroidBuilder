Task: Eliminate “first-click flicker” and finish Phase 5A wiring safely
Files you may change (only these)

client/src/contexts/GameContext.jsx (or .tsx)

client/src/components/Game/GameScreen.tsx (where Start Menu and main game UI render)

client/src/contexts/InventoryContext.jsx

0) Pre-flight: prove there’s only one init trigger

Run:

rg -n "initializeGame\\(" client/src | sed 's/^/CALLSITE: /'
rg -n "useEffect\\(.*initializeGame" client/src | sed 's/^/AUTO-INIT: /'


Expected: exactly one CALLSITE (Start Menu handler), zero AUTO-INIT. If any useEffect(... initializeGame() exists (e.g., in MapInterface.tsx), remove it.

1) Make initializeGame() race-proof (ref-based, restartable)

File: GameContext.jsx

Mirror init state into a ref; guard using the ref, not the captured state.

Block only when actively initializing ('preloading'|'core_setup'|'world_population').

Allow explicit “New Game” restarts from 'idle'|'complete'|'error'.

Add a runIdRef and ignore late events from older runs.

Skeleton (adapt names/types as needed):

const [initState, setInitState] = useState<'idle'|'preloading'|'core_setup'|'world_population'|'complete'|'error'>('idle');
const initRef = useRef(initState);
useEffect(() => { initRef.current = initState; }, [initState]);

const runIdRef = useRef(0);
const initManagerRef = useRef<GameInitializationManager | null>(null);

function wireManagerEvents(manager: GameInitializationManager, runId: number) {
  manager.on('stateChanged', (next) => {
    if (runId !== runIdRef.current) return;
    setInitState(next);
  });
  manager.on('initializationComplete', () => {
    if (runId !== runIdRef.current) return;
    setIsGameReady(true);
  });
  manager.on('initializationError', (err) => {
    if (runId !== runIdRef.current) return;
    setInitializationError(err);
  });
}

const initializeGame = useCallback(async (loadAfter = false, slot = 'autosave', explicitNewGame = false) => {
  const now = initRef.current;

  // restart when requested from terminal states
  if (explicitNewGame && (now === 'complete' || now === 'error')) {
    runIdRef.current += 1;
    setIsGameReady(false);
    setInitializationError(null);
    setInitState('idle');
    // optional: dispose/recreate manager & rewire
    initManagerRef.current?.dispose?.();
    initManagerRef.current = new GameInitializationManager();
    wireManagerEvents(initManagerRef.current, runIdRef.current);
  }

  // block only while actively initializing
  if (['preloading','core_setup','world_population'].includes(initRef.current)) {
    console.log('[GameContext] initializeGame ignored; already initializing:', initRef.current);
    return;
  }

  // optimistic lock: prevents double starts from rapid clicks
  setInitState('preloading');

  await initManagerRef.current!.startInitialization(loadAfter, slot /*, runIdRef.current if supported */);
}, []);


Ensure the manager is created on mount but not auto-started, and wireManagerEvents(initManagerRef.current, runIdRef.current) is called once then (and again if you recreate it for a new run).

2) Start Menu: don’t hide until init actually starts

File: GameScreen.tsx

Keep a local isStarting guard to stop double-clicks.

Hide the menu only after we detect the first init state transition (e.g., 'preloading'), not immediately on click.

Example:

const [isStarting, setIsStarting] = useState(false);
const { initState, initializeGame } = useGame();

useEffect(() => {
  if (initState === 'preloading') setShowStartMenu(false);
}, [initState]);

const handleStartGame = async () => {
  if (isStarting) return;
  setIsStarting(true);
  try {
    await initializeGame(false, 'autosave', true);
  } finally {
    setIsStarting(false);
  }
};


Acceptance for this step: First click → menu fades once (no flicker back), init proceeds.

3) Inventory provider: mount once, only after manager exists

Choose one place to mount <InventoryProvider>. The safest, least racy option is inside GameContext.jsx or inside GameScreen.tsx around the inventory UI only—but never around the entire app.

If you keep it in GameContext.jsx, gate it like this:

return (
  <GameContext.Provider value={contextValue}>
    {inventoryManager
      ? <InventoryProvider manager={inventoryManager}>{children}</InventoryProvider>
      : children}
  </GameContext.Provider>
);


If you prefer to move it to GameScreen.tsx, ensure it only wraps the inventory UI subtree and only when isGameReady && inventoryManager. Do not wrap Start Menu or world providers.

Do not mount the provider in both places. Verify:

rg -n "<InventoryProvider" client/src
# expect exactly one occurrence

4) Provider null-manager handling (no black screens)

File: InventoryContext.jsx

If the provider ever renders without a manager (should be rare due to step 3), pass children through rather than null:

if (!manager) {
  if (import.meta?.env?.DEV) console.warn('[InventoryProvider] waiting for manager (pass-through)');
  return <>{children}</>;
}


Keep the dev-console bridge only in the “has manager” path.

5) Acceptance checklist (must all pass)

Single entry point: rg -n "initializeGame\\(" client/src → exactly one call (Start Menu).

No auto-init effects: rg -n "useEffect\\(.*initializeGame" client/src → 0.

First click works: Click New Game once → you see the sequence idle → preloading → core_setup → world_population → complete; Start Menu hides after 'preloading', no flicker back.

Provider mount: rg -n "<InventoryProvider" client/src → one match. Inventory UI only appears after inventoryManager exists.

Dev bridge (if enabled): After init, window.inventoryManager exists and window.inv.getContainer('ground') works.

No layout/visual regressions.