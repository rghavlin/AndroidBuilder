1) Mount the preview once at the app/root (not inside a panel)

Render the preview layer once so it’s always in the DOM and on the highest z-layer.

// App.tsx (or whatever your top-level UI shell is)
import DragPreviewLayer from "@/components/Inventory/DragPreviewLayer";

export default function App() {
  return (
    <>
      {/* ...your providers... */}
      {/* InventoryProvider should wrap this so context is available */}
      <YourInventoryProvider>
        {/* ...rest of UI... */}
        <DragPreviewLayer /> {/* <-- always mounted */}
      </YourInventoryProvider>
    </>
  );
}


If you already render it somewhere, move it out of panels/containers that create stacking contexts (borders/overflow/etc). Rendering via a portal (below) plus a huge z-index avoids clipping.

2) Make the preview layer a high-z portal with immediate render

This version:

Uses createPortal(document.body).

Renders immediately using the cursor coordinates from beginDrag.

Tracks further movement via mousemove (but you’ll also set the initial position in step 3).

Shows a dashed placeholder if no image yet.

Uses pointer-events:none and a very high z-index.

// client/src/components/Inventory/DragPreviewLayer.tsx
import React, { useEffect } from "react";
import { createPortal } from "react-dom";
import { useInventory } from "@/contexts/InventoryContext";

export default function DragPreviewLayer() {
  const { dragState, updateDragPosition } = useInventory(); // assumes these exist

  // Keep following the cursor globally
  useEffect(() => {
    const onMove = (e: MouseEvent) => {
      updateDragPosition(e.clientX, e.clientY);
    };
    window.addEventListener("mousemove", onMove);
    return () => window.removeEventListener("mousemove", onMove);
  }, [updateDragPosition]);

  if (!dragState) return null;

  const {
    item,
    cursorX = 0,
    cursorY = 0,
    rotation = 0,
    slotSize = 32,
    gapSize = 2,
    previewSrc, // optional (see step 3)
  } = dragState;

  const widthSlots = item?.width ?? item?.w ?? 1;
  const heightSlots = item?.height ?? item?.h ?? 1;

  // size to match your grid’s math
  const pxW = widthSlots * slotSize + (widthSlots - 1) * gapSize;
  const pxH = heightSlots * slotSize + (heightSlots - 1) * gapSize;

  const node = (
    <div
      style={{
        position: "fixed",
        left: 0,
        top: 0,
        transform: `translate(${cursorX}px, ${cursorY}px) translate(-50%, -50%) rotate(${rotation * 90}deg)`,
        zIndex: 2147483647, // on top of everything
        pointerEvents: "none",
        willChange: "transform",
        filter: "drop-shadow(0 0 2px rgba(0,0,0,.6))",
      }}
      data-test-id="drag-preview"
    >
      {previewSrc ? (
        <img
          src={previewSrc}
          alt={item?.name ?? "drag-item"}
          style={{ width: pxW, height: pxH, display: "block", imageRendering: "pixelated" }}
        />
      ) : (
        <div
          style={{
            width: pxW,
            height: pxH,
            outline: "2px dashed #ffd400",
            background: "rgba(255,212,0,.15)",
            borderRadius: 2,
          }}
        />
      )}
    </div>
  );

  return createPortal(node, document.body);
}

3) Ensure dragState is initialized with position (no waiting for mousemove)

Set the cursor position, slot/gap sizes, and (optionally) a preview image inside beginDrag so the preview shows on the first frame.

// client/src/contexts/InventoryContext.jsx
function beginDrag({ item, originContainerId, originX, originY, rotation = 0, cursorX, cursorY, slotSize, gapSize, previewSrc }) {
  // remove from container here (you already do this)
  setDragState({
    item,
    originContainerId,
    originX,
    originY,
    rotation,
    cursorX, // initial position from the click event
    cursorY,
    slotSize, // pass from the grid that started the drag
    gapSize,  // pass from the grid that started the drag
    previewSrc: previewSrc ?? null, // optional if you have a resolver
  });
}

function updateDragPosition(x, y) {
  setDragState(prev => (prev ? { ...prev, cursorX: x, cursorY: y } : prev));
}


And when you start the drag from the grid, pass the correct values:

// client/src/components/Inventory/UniversalGrid.tsx
const onMouseDownItem = (e, item, gridX, gridY) => {
  // prevent text selection, etc.
  e.preventDefault();

  beginDrag({
    item,
    originContainerId: containerId,
    originX: gridX,
    originY: gridY,
    rotation: 0,
    cursorX: e.clientX,
    cursorY: e.clientY,
    slotSize,         // whatever this grid uses (e.g., 32)
    gapSize: GAP_SIZE // whatever this grid uses (e.g., 2)
    // previewSrc: resolveItemImage(item) // optional if you have it
  });
};


Key point: Do not rely on the first mousemove to place the preview; you already know the click’s clientX/clientY. Initializing dragState with those values makes the preview render instantly.

4) Common culprits this also addresses

Stacking context / z-index: Portal to document.body + giant z-index prevents the preview from being hidden.

Pointer capture: pointer-events:none keeps the preview from intercepting events.

Async image load: The placeholder silhouette removes the “vanishes” feeling even if the image isn’t ready.

No re-render: setDragState({ ...prev, cursorX, cursorY }) ensures new object identity so React re-renders.

If you still don’t see the preview after this, add a one-time sanity check: put console.log("[DragPreviewLayer] mounted") at the top of the component. If it doesn’t log, it’s not being mounted (import path or file name mismatch). If it logs and still nothing renders, toggle the placeholder (remove previewSrc) to force the yellow dashed rectangle — that’ll tell us if it’s an image-path issue vs. a render-path issue.