Recovery & Phase 5 (redo) plan

I’m splitting this into tiny subphases. Each subphase is a single PR with a short acceptance checklist.

5A — Unify the InventoryManager (foundation)

Goal: Ensure the same InventoryManager instance is used by initialization, context, and UI.

Implementation (tiny and safe):

Create, don’t duplicate. Move new InventoryManager(...) to one place at startup (ideally in your GameInitializationManager or a top-level “services” bootstrap).

Plumb it into context. Change InventoryProvider to accept a manager prop and stop constructing its own. Provide that instance via context.

Mount order: Wrap any component that uses useInventory() with this provider after the manager is created (same frame is fine).

Dev-console bridge: In a useEffect inside InventoryProvider, do window.inventoryManager = manager; (dev builds only). Also expose a window.inv = { getContainer, equipItem, moveItem } helper that calls through the context. It keeps console flows consistent.

Acceptance (console-driven):

window.inventoryManager exists and getContainer('ground') returns a grid snapshot.

Ground grid UI reappears with any seeded items (no “no ground container available” message).

Resizing the window does not change slot pixel size across any inventory grid.

5B — Equipment slots (read-only, visual unchanged)

Goal: Show what’s equipped using the existing icon UI, no drag/drop or layout tweaks.

Implementation:

EquipmentSlots.tsx: call useInventory(); read manager.equipment[slot] for each of the seven canonical slots; pass equippedItem to EquipmentSlot.

EquipmentSlot.tsx: do not change icons or dimensions. Add a tooltip/title that shows equippedItem?.name if present.

No click logic yet (or just console.debug).

Acceptance:

Equipping via console (see commands below) updates the slot visuals (occupied vs empty) and the tooltip displays the item name.

No changes to fonts, emojis/icons, or layout.

Console quick test:

// ensure foundation
window.inventoryManager && window.inventoryManager.getContainer('ground');
// create + equip a backpack (use your project’s helper/defs)
const bp = window.inventoryManager.createItem('backpack_basic');
window.inventoryManager.equipItem(bp, 'backpack');
// the backpack slot shows occupied; tooltip shows the name

5C — Backpack panel toggle (unchanged visuals)

Goal: Clicking the Backpack equipment slot shows/hides the backpack’s grid only if a backpack is equipped.

Implementation:

Add a small local useState in the equipment panel for Backpack visibility.

On click of the backpack slot:

If a backpack is not equipped → no-op (or a subtle message in console).

If equipped → toggle <ContainerGrid containerId={getEquippedBackpackContainerId()}/>.

Use the global fixed slot size for the grid, no CSS/layout edits.

Acceptance:

Equipping a backpack then clicking the slot reveals a grid; unequipping or closing hides it.

Grid slot pixel size matches ground grid.

5D — Nested specialty containers: read-only open

Goal: Click a specialty container item (e.g., lunchbox) inside any container to open a small floating inline panel rendering that item’s own container grid. No drag/drop yet.

Implementation:

Add openableWhenNested(itemOrDefId) to context if missing; make it return false for backpacks, true for specialty containers.

In ContainerGrid, intercept item click:

If openableWhenNested(item) → open <FloatingContainer containerId={item.containerId}/> anchored to the click position; track open panels by containerId to avoid duplicates.

Else → ignore (for now).

Each FloatingContainer reads slot size from the same GridSizeContext.fixedSlotSize.

Acceptance:

Clicking a lunchbox item in a backpack opens its own grid in a floating panel.

Clicking a backpack item does not open inline (must be equipped and opened through 5C).

Multiple distinct specialty containers can be opened at once (each has a distinct containerId).

5E — Minimal interactions (1): move ground ↔ backpack via context

Goal: Enable moving items between ground and backpack using your existing moveItem(...) from context. Keep UI unchanged—just make current drag or click-to-move call the context.

Implementation:

Wherever the grid currently handles a drop, call:

moveItem({
  fromContainerId, toContainerId,
  fromPos, toPos,
  qty // optional for splitting
})


On failure, show a small toast/console reason; no partial moves.

Acceptance:

One item can be moved ground → backpack and back without errors.

Invalid overlaps/out-of-bounds are rejected, leaving state untouched.

5F — Minimal interactions (2): nested specialty containers

Goal: Allow moves into/out of an open specialty container panel (same moveItem API). Still no visual redesign.

Implementation:

The floating panel’s ContainerGrid participates in the same drop logic. The only “special” handling is closing the panel when its source item is removed/ejected (listen to version changes and verify getContainer(containerId) still exists).

Acceptance:

Drag an item from backpack into an open lunchbox panel and back.

Closing the panel or removing the lunchbox removes its panel cleanly.

Guardrails that prevent the previous failure

Provider takes a manager; it never constructs one.
This removes the “two managers” class of bugs entirely.

Foundation-first QA gates: 5A (unified manager + ground visible) and 5B (read-only equipment) must pass before any interaction code merges.

No visual/layout churn: 5B–5F avoid touching icons, sizes, or CSS. You’ll see real logic changes without masking them behind UI shifts.

Console-first testing: All steps are verifiable using window.inventoryManager and a tiny script, so you catch wiring issues early.

Suggested commit slices

feat(inventory): provider accepts external manager; remove internal construction

fix(inventory): mount provider where useInventory() is consumed

feat(inventory-ui): read-only equipment slots (no visual changes)

feat(inventory-ui): backpack panel toggle when equipped

feat(inventory-ui): open nested specialty containers read-only

feat(inventory): grid moveItem wiring (ground↔backpack)

feat(inventory): moves for open specialty containers

Each is easy to review/revert.

Quick troubleshooting matrix (if something breaks)

Ground grid missing: window.inventoryManager undefined, or provider still constructing its own manager; or provider mounted outside the UI subtree that renders inventory.

Backpack grid not showing: No equipped backpack; or getEquippedBackpackContainerId() returns null; or panel toggle guarded incorrectly.

Nested panel opens for backpacks: openableWhenNested not checking def type; enforce “false” for backpacks.

Drag drops do nothing: UI handler not calling moveItem(...); or fromPos/toPos computed in pixels instead of slots; or container IDs mismatched (use the containerId from getContainer snapshots).