The minimal item model (Phase-4 friendly)
1) Static catalog: ItemDef

Immutable definitions you load once at startup (JSON or TS object).

// systems/inventory/ItemDefs.ts
export type ItemType = 'backpack' | 'consumable' | 'weapon' | 'junk';

export interface ItemDef {
  id: string;             // 'backpack_small'
  type: ItemType;         // 'backpack'
  name: string;           // 'Small Backpack'
  size?: [number, number]; // grid footprint (cols, rows), default [1,1]
  stackable?: boolean;    // default false
  maxStack?: number;      // if stackable
  capacity?: [number, number]; // only for backpacks/containers
  tags?: string[];        // 'cloth','starter'
}

export const ITEM_DEFS: Record<string, ItemDef> = {
  backpack_small: { id:'backpack_small', type:'backpack', name:'Small Backpack', capacity:[6,4] },
  bandage:        { id:'bandage', type:'consumable', name:'Bandage', stackable:true, maxStack:10 },
  scrap_wire:     { id:'scrap_wire', type:'junk', name:'Scrap Wire', stackable:true, maxStack:20 },
  knife_kitchen:  { id:'knife_kitchen', type:'weapon', name:'Kitchen Knife' },
};

2) Runtime item: Item

Instances that live in containers, serialize cleanly.

// systems/inventory/Item.ts
import { ITEM_DEFS, ItemDef } from './ItemDefs';

export interface ItemJSON { id: string; defId: string; qty?: number; meta?: any; }

export class Item {
  id: string;             // stable uuid
  defId: string;          // key into catalog
  qty: number;
  meta: any;

  constructor(defId: string, id: string, qty=1, meta?: any) {
    this.id = id; this.defId = defId; this.qty = qty; this.meta = meta ?? {};
  }
  def(): ItemDef { return ITEM_DEFS[this.defId]; }
  toJSON(): ItemJSON { return { id:this.id, defId:this.defId, qty:this.qty, meta:this.meta }; }
  static fromJSON(j: ItemJSON): Item { return new Item(j.defId, j.id, j.qty ?? 1, j.meta); }
}

3) Containers & equipment linkage

One generic container type for grids; equipment just points at a container.

// systems/inventory/Container.ts
import { Item } from './Item';

export interface ContainerJSON { id:string; cols:number; rows:number; slots:(string|null)[]; }

export class Container {
  id: string; cols: number; rows: number;
  slots: (Item|null)[];
  constructor(id:string, cols:number, rows:number){ this.id=id; this.cols=cols; this.rows=rows; this.slots=Array(cols*rows).fill(null); }
  toJSON(): ContainerJSON { return { id:this.id, cols:this.cols, rows:this.rows, slots:this.slots.map(i=>i?.toJSON()?.id ?? null) }; }
}

// systems/inventory/InventoryManager.ts
import { Item, ItemJSON } from './Item';
import { Container, ContainerJSON } from './Container';
import { ITEM_DEFS } from './ItemDefs';

export interface InventoryJSON {
  containers: Record<string, ContainerJSON>;
  items: Record<string, ItemJSON>;
  equipped: { backpackContainerId?: string };
}

export class InventoryManager {
  containers = new Map<string, Container>();
  items = new Map<string, Item>();
  equipped: { backpackContainerId?: string } = {};

  createBackpackContainer(defId:'backpack_small'): string {
    const def = ITEM_DEFS[defId];
    const id = `cont_${crypto.randomUUID()}`;
    const [cols, rows] = def.capacity ?? [6,4];
    this.containers.set(id, new Container(id, cols, rows));
    return id;
  }

  equipBackpack(itemId: string) {
    const item = this.items.get(itemId);
    if (!item || ITEM_DEFS[item.defId].type !== 'backpack') throw new Error('Not a backpack');
    // attach (create if needed) a container for this backpack
    const cid = this.createBackpackContainer(item.defId as any);
    this.equipped.backpackContainerId = cid;
  }

  getEquippedBackpackContainerId() { return this.equipped.backpackContainerId ?? null; }

  toJSON(): InventoryJSON {
    return {
      containers: Object.fromEntries([...this.containers].map(([k,c])=>[k,c.toJSON()])),
      items: Object.fromEntries([...this.items].map(([k,i])=>[k,i.toJSON()])),
      equipped: { ...this.equipped },
    };
  }
  static fromJSON(j: InventoryJSON): InventoryManager {
    const im = new InventoryManager();
    im.equipped = { ...j.equipped };
    // (Youâ€™ll rehydrate items/containers fully in your real code.)
    return im;
  }
}


This keeps pure JS logic isolated, matches your Phase-4 style, and is easy to serialize.